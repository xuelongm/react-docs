<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>概览 | React Docs</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="docs React 17x">
    
    <link rel="preload" href="/react-docs/assets/css/0.styles.81a1deae.css" as="style"><link rel="preload" href="/react-docs/assets/js/app.ba34e162.js" as="script"><link rel="preload" href="/react-docs/assets/js/2.ba3186f0.js" as="script"><link rel="preload" href="/react-docs/assets/js/16.544c3c3d.js" as="script"><link rel="prefetch" href="/react-docs/assets/js/10.97b71cf3.js"><link rel="prefetch" href="/react-docs/assets/js/11.8e76ad41.js"><link rel="prefetch" href="/react-docs/assets/js/12.d7ad81f6.js"><link rel="prefetch" href="/react-docs/assets/js/13.355108e6.js"><link rel="prefetch" href="/react-docs/assets/js/14.c1fd98bc.js"><link rel="prefetch" href="/react-docs/assets/js/15.4d51d0b9.js"><link rel="prefetch" href="/react-docs/assets/js/3.5d9530b1.js"><link rel="prefetch" href="/react-docs/assets/js/4.53506a7c.js"><link rel="prefetch" href="/react-docs/assets/js/5.02fdfb65.js"><link rel="prefetch" href="/react-docs/assets/js/6.8eb97706.js"><link rel="prefetch" href="/react-docs/assets/js/7.a6b7cea6.js"><link rel="prefetch" href="/react-docs/assets/js/8.91c67b7a.js"><link rel="prefetch" href="/react-docs/assets/js/9.539d3027.js">
    <link rel="stylesheet" href="/react-docs/assets/css/0.styles.81a1deae.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/react-docs/" class="home-link router-link-active"><!----> <span class="site-name">React Docs</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/react-docs/" class="nav-link">
  Home
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/react-docs/" class="nav-link">
  Home
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/react-docs/" aria-current="page" class="sidebar-link">首页</a></li><li><a href="/react-docs/concept.html" class="sidebar-link">概念篇</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>render</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>commit</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>diff</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>状态更新</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react-docs/state/state.html" aria-current="page" class="active sidebar-link">概览</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react-docs/state/state.html#update对象" class="sidebar-link">Update对象</a></li><li class="sidebar-sub-header"><a href="/react-docs/state/state.html#updatequeue对象" class="sidebar-link">updateQueue对象</a></li><li class="sidebar-sub-header"><a href="/react-docs/state/state.html#正确性" class="sidebar-link">正确性</a></li><li class="sidebar-sub-header"><a href="/react-docs/state/state.html#update状态的连续性" class="sidebar-link">update状态的连续性</a></li></ul></li><li><a href="/react-docs/state/render.html" class="sidebar-link">渲染及更新</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>hooks</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="概览"><a href="#概览" class="header-anchor">#</a> 概览</h1> <p>在React中有那些行为可以触发状态更新：</p> <ul><li>ReactDOM.render：在legacy模式下的HostRoot</li> <li>new ReactDOMRoot('').render：concurrent模式下的HostRoot</li> <li>this.setState：ClassComponent类型的更新</li> <li>this.forceUpdate：ClassComponent类型的更新</li> <li>useState：FunctionComponent类型的更新</li> <li>useReducer：FunctionComponent类型的更新</li></ul> <p>上面为React中触发更新的全部行为，这些行为背后究竟做了什么，保证了React可以在legacy或concurrent模式下的正确更新的呢？在进入正片开始之前，我们要有几个前置知识。</p> <h2 id="update对象"><a href="#update对象" class="header-anchor">#</a> Update对象</h2> <p>什么是<code>Update</code>对象呢？简单来说，<code>Update</code>对象为一种数据结构，主要分为两种类型，一种是为<code>ClassComponent</code>和<code>HostRoot</code>服务的结构，一种是为了<code>FunctionCompnent</code>服务的。</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token comment">// ClassComponent和HostRoot 类型的Update</span>
<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  eventTime<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
  lane<span class="token operator">:</span> Lane<span class="token punctuation">,</span>
  tag<span class="token operator">:</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token punctuation">,</span>
  payload<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span>
  callback<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> mixed<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  next<span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// FunctionComponent 类型的update</span>
<span class="token keyword">type</span> <span class="token class-name">Update<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  lane<span class="token operator">:</span> Lane<span class="token punctuation">,</span>
  action<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">,</span>
  eagerReducer<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">A</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">S</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  eagerState<span class="token operator">:</span> <span class="token constant">S</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  next<span class="token operator">:</span> Update<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  priority<span class="token operator">?</span><span class="token operator">:</span> ReactPriorityLevel<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>本章我们以<code>ClassComponent</code>和<code>HostRoot</code>状态更新为主，暂时可以忽略<code>FunctionComponent</code>类型的Update（下一章我们介绍Hooks时会详细的介绍）。那么让我们来看看各个字段的含义：</p> <ul><li>eventTime：任务时间，通过<code>performance.now()</code>获取的毫秒数。</li> <li>lane：优先级字段，后面可能会涉及一部分优先级的内容。</li> <li>tag：更新类型：UpdateState， ReplaceState，  ForceUpdate ，CaptureUpdate。</li> <li>payload：payloay为setState的第一参数。</li> <li>callback：为setState的第二参数，会在Commit阶段调用，我们在Commit阶段讲过，这个参数会放入到<code>fiber.updateQueue.effects</code>中</li> <li>next：下个一个update</li></ul> <p>那么React中是怎么保存Update呢？</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
      count<span class="token operator">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token function">onclickHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">count</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">count</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onclickHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面的栗子中，在React中会形成什么样的数据结构呢？</p> <blockquote><p>我们在<code>onclickHandler</code>调用了两次<code>setState</code>，那么渲染几次，答案是1次（因为是在onClick的回调中设置的，在React的消息中会触发批更新）。</p></blockquote> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token comment">// update1 --&gt; 表示第一次调用setState创建的Update</span>
<span class="token comment">// update2 --&gt; 表示第二次调用setState创建的Update</span>
<span class="token comment">// 最终会形成一个环状链表</span>
update1<span class="token punctuation">.</span>next <span class="token operator">=</span> update2<span class="token punctuation">;</span>
update2<span class="token punctuation">.</span>next <span class="token operator">=</span> update2<span class="token punctuation">;</span>
fiber<span class="token punctuation">.</span>updateQueue<span class="token punctuation">.</span>shared<span class="token punctuation">.</span>pending <span class="token operator">=</span> update2<span class="token punctuation">;</span>
</code></pre></div><p>创建的Update会形成一个环状链表，并且挂载到<code>fiber.updateQueue.shared.pending</code>上。</p> <p>我们来先看看Update环状链表创建函数<code>enqueueUpdate</code></p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">enqueueUpdate</span><span class="token generic class-name"><span class="token operator">&lt;</span>State<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>fiber<span class="token operator">:</span> Fiber<span class="token punctuation">,</span> update<span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> updateQueue <span class="token operator">=</span> fiber<span class="token punctuation">.</span>updateQueue<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>updateQueue <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> sharedQueue<span class="token operator">:</span> SharedQueue<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">(</span>updateQueue<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">.</span>shared<span class="token punctuation">;</span>
  <span class="token keyword">const</span> pending <span class="token operator">=</span> sharedQueue<span class="token punctuation">.</span>pending<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>pending <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    update<span class="token punctuation">.</span>next <span class="token operator">=</span> update<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    update<span class="token punctuation">.</span>next <span class="token operator">=</span> pending<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    pending<span class="token punctuation">.</span>next <span class="token operator">=</span> update<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  sharedQueue<span class="token punctuation">.</span>pending <span class="token operator">=</span> update<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>由代码可以看出，<code>enqueueUpdate</code>函数相当简单，下面我们举个栗子来说明这个链表形成的过程：</p> <p>假设我们要创建四个Update，分别为：A，B，C，D，创建过程如下：</p> <blockquote><p>下面的pending即为fiber.updateQueue.pending</p></blockquote> <ul><li>创建A，此时：pending === null，A.next = A &amp;&amp;  <code>fiber.updateQueue.pending</code> = A，此时的链表：A.next === A，pending === A，pending.next === A。</li> <li>创建B，当执行<code>update.next = pending.next</code>时，也就是B.next = A，形成环状，当执行<code>pending.next = update</code>时，也就是A.next = B，最后执行<code>sharedQueue.pending = update</code>，也就是pending === B。此时的链表：A.next === B，B.next === A, pending === B，pending.next === A。</li> <li>创建C，当执行<code>update.next = pending.next</code>时，也就是C.next = A，形成环状，当执行<code>pending.next = update</code>时，也就是B.next = C，最后执行<code>sharedQueue.pending = update</code>，也就是pending === C。此时的链表：A.next === B，B.next === A, pending === B，pending.next === A。</li> <li>创建D，重复上面创建C的过程。</li></ul> <blockquote><p>pending最终指向的是环状链表中的最后一个元素，而pending.next才是指向环状链表的第一个元素。</p></blockquote> <p>下面让我们看看<code>updateQueue</code>类型：</p> <h2 id="updatequeue对象"><a href="#updatequeue对象" class="header-anchor">#</a> updateQueue对象</h2> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">type</span> <span class="token class-name">SharedQueue<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  pending<span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">UpdateQueue<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  baseState<span class="token operator">:</span> State<span class="token punctuation">,</span>
  firstBaseUpdate<span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  lastBaseUpdate<span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  shared<span class="token operator">:</span> SharedQueue<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  effects<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span>Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p><code>UpdateQueue</code>对象保存了当前fiber需要更新的全部<code>Update</code>（不仅仅是本次更新触发的Update）。</p> <ul><li>baseState：本次更新的基础值，和<code>fiber.memoizedState</code>可能相等（上次更新，全部更新完成），也可能不相等（上次更新没有更新完成）。</li> <li>firstBaseUpdate：更新的开始Update，如果上次更新没有完全更新，本次计算开始时<code>firstBaseUpdate</code>不为空。</li> <li>lastBaseUpdate：更新最终的Update，如果上次更新没有完全更新，本次计算开始时<code>lastBaseUpdate</code>不为空。</li> <li>share：本次更新所有Update。</li> <li>effects：setState第二个参数。</li></ul> <p>好，下面让我们来看根据Update计算出memoizedState的过程<code>processUpdateQueue</code>函数：</p> <blockquote><p>下面函数比较复杂，我会详细的写注释，具体的流程可以重复跟踪下代码</p></blockquote> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">processUpdateQueue</span><span class="token generic class-name"><span class="token operator">&lt;</span>State<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>
  workInProgress<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  props<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span>
  instance<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span>
  renderLanes<span class="token operator">:</span> Lanes<span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
 <span class="token comment">// This is always non-null on a ClassComponent or HostRoot</span>
  <span class="token comment">// 获取当前fiber的updateQueue</span>
  <span class="token keyword">const</span> queue<span class="token operator">:</span> UpdateQueue<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">(</span>workInProgress<span class="token punctuation">.</span>updateQueue<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  hasForceUpdate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    currentlyProcessingQueue <span class="token operator">=</span> queue<span class="token punctuation">.</span>shared<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 如果上次更新没有全部更新完成，当前的firstBaseUpdate不为null</span>
  <span class="token keyword">let</span> firstBaseUpdate <span class="token operator">=</span> queue<span class="token punctuation">.</span>firstBaseUpdate<span class="token punctuation">;</span>
  <span class="token comment">// 同上面的firstBaseUpdate</span>
  <span class="token keyword">let</span> lastBaseUpdate <span class="token operator">=</span> queue<span class="token punctuation">.</span>lastBaseUpdate<span class="token punctuation">;</span>

  <span class="token comment">// 获取本次更新的环状链表</span>
  <span class="token keyword">let</span> pendingQueue <span class="token operator">=</span> queue<span class="token punctuation">.</span>shared<span class="token punctuation">.</span>pending<span class="token punctuation">;</span>
  <span class="token comment">// 如果本次有更新</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>pendingQueue <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 重置pending，为下次更新做准备</span>
    queue<span class="token punctuation">.</span>shared<span class="token punctuation">.</span>pending <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 上面说过，queue.shared.pending 是指向环状链表的最后一个元素</span>
    <span class="token comment">// pengding.next 才是指向第一个元素</span>
    <span class="token keyword">const</span> lastPendingUpdate <span class="token operator">=</span> pendingQueue<span class="token punctuation">;</span>
    <span class="token comment">// 获取第一个元素</span>
    <span class="token keyword">const</span> firstPendingUpdate <span class="token operator">=</span> lastPendingUpdate<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token comment">// 剪断环状链表</span>
    lastPendingUpdate<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果为空，则将当前链表设置为firstBaseUpdate</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lastBaseUpdate <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      firstBaseUpdate <span class="token operator">=</span> firstPendingUpdate<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果lastBaseUpdate不为空，将当前链表加在后面</span>
      lastBaseUpdate<span class="token punctuation">.</span>next <span class="token operator">=</span> firstPendingUpdate<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 更新最终的链表</span>
    lastBaseUpdate <span class="token operator">=</span> lastPendingUpdate<span class="token punctuation">;</span>

    <span class="token comment">// 讲当前链表加在 workInProgress.alternate链表的后面，防止被打断后数据丢失</span>
    <span class="token comment">// 此处要记住，react更新都是从root开始，且只存在一棵workInProgress树</span>
    <span class="token keyword">const</span> current <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// This is always non-null on a ClassComponent or HostRoot</span>
      <span class="token keyword">const</span> currentQueue<span class="token operator">:</span> UpdateQueue<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>updateQueue<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> currentLastBaseUpdate <span class="token operator">=</span> currentQueue<span class="token punctuation">.</span>lastBaseUpdate<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>currentLastBaseUpdate <span class="token operator">!==</span> lastBaseUpdate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentLastBaseUpdate <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          currentQueue<span class="token punctuation">.</span>firstBaseUpdate <span class="token operator">=</span> firstPendingUpdate<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          currentLastBaseUpdate<span class="token punctuation">.</span>next <span class="token operator">=</span> firstPendingUpdate<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        currentQueue<span class="token punctuation">.</span>lastBaseUpdate <span class="token operator">=</span> lastPendingUpdate<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 这个fiber有更新</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>firstBaseUpdate <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取更新的base</span>
    <span class="token keyword">let</span> newState <span class="token operator">=</span> queue<span class="token punctuation">.</span>baseState<span class="token punctuation">;</span>
    <span class="token comment">// 优先级</span>
    <span class="token keyword">let</span> newLanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>
    <span class="token comment">// 这个变量是为了本次更新优先级不同，在遇到第一个低优先级时，保存前面已计算的base</span>
    <span class="token keyword">let</span> newBaseState <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 不同优先级时，保存第一个遇到的低优先级的update</span>
    <span class="token keyword">let</span> newFirstBaseUpdate <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// // 不同优先级时，本次未更新的最后一个update</span>
    <span class="token keyword">let</span> newLastBaseUpdate <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> update <span class="token operator">=</span> firstBaseUpdate<span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> updateLane <span class="token operator">=</span> update<span class="token punctuation">.</span>lane<span class="token punctuation">;</span>
      <span class="token keyword">const</span> updateEventTime <span class="token operator">=</span> update<span class="token punctuation">.</span>eventTime<span class="token punctuation">;</span>
      <span class="token comment">// 判断优先级是否在本次更新的优先级之内，如果不在，则跳过本次updata</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isSubsetOfLanes</span><span class="token punctuation">(</span>renderLanes<span class="token punctuation">,</span> updateLane<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Priority is insufficient. Skip this update. If this is the first</span>
        <span class="token comment">// skipped update, the previous update/state is the new base</span>
        <span class="token comment">// update/state.</span>
        <span class="token keyword">const</span> clone<span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
          eventTime<span class="token operator">:</span> updateEventTime<span class="token punctuation">,</span>
          lane<span class="token operator">:</span> updateLane<span class="token punctuation">,</span>

          tag<span class="token operator">:</span> update<span class="token punctuation">.</span>tag<span class="token punctuation">,</span>
          payload<span class="token operator">:</span> update<span class="token punctuation">.</span>payload<span class="token punctuation">,</span>
          callback<span class="token operator">:</span> update<span class="token punctuation">.</span>callback<span class="token punctuation">,</span>

          next<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newLastBaseUpdate <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 低于本次更新的第一个update</span>
          newFirstBaseUpdate <span class="token operator">=</span> newLastBaseUpdate <span class="token operator">=</span> clone<span class="token punctuation">;</span>
          <span class="token comment">// 保存前面已计算出来的base</span>
          newBaseState <span class="token operator">=</span> newState<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          newLastBaseUpdate <span class="token operator">=</span> newLastBaseUpdate<span class="token punctuation">.</span>next <span class="token operator">=</span> clone<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// Update the remaining priority in the queue.</span>
        <span class="token comment">// 更新优先级</span>
        newLanes <span class="token operator">=</span> <span class="token function">mergeLanes</span><span class="token punctuation">(</span>newLanes<span class="token punctuation">,</span> updateLane<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// This update does have sufficient priority.</span>
        <span class="token comment">// 如果有跳过的更新，要从跳过更新处后，所有的update都要保存</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newLastBaseUpdate <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> clone<span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
            eventTime<span class="token operator">:</span> updateEventTime<span class="token punctuation">,</span>
            <span class="token comment">// This update is going to be committed so we never want uncommit</span>
            <span class="token comment">// it. Using NoLane works because 0 is a subset of all bitmasks, so</span>
            <span class="token comment">// this will never be skipped by the check above.</span>
            lane<span class="token operator">:</span> NoLane<span class="token punctuation">,</span>

            tag<span class="token operator">:</span> update<span class="token punctuation">.</span>tag<span class="token punctuation">,</span>
            payload<span class="token operator">:</span> update<span class="token punctuation">.</span>payload<span class="token punctuation">,</span>
            callback<span class="token operator">:</span> update<span class="token punctuation">.</span>callback<span class="token punctuation">,</span>

            next<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
          <span class="token punctuation">}</span><span class="token punctuation">;</span>
          newLastBaseUpdate <span class="token operator">=</span> newLastBaseUpdate<span class="token punctuation">.</span>next <span class="token operator">=</span> clone<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Process this update.</span>
        <span class="token comment">// 更新state</span>
        newState <span class="token operator">=</span> <span class="token function">getStateFromUpdate</span><span class="token punctuation">(</span>
          workInProgress<span class="token punctuation">,</span>
          queue<span class="token punctuation">,</span>
          update<span class="token punctuation">,</span>
          newState<span class="token punctuation">,</span>
          props<span class="token punctuation">,</span>
          instance<span class="token punctuation">,</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 是否有callback，如果有callback，则将callback，保存在effects中，在commit阶段调用</span>
        <span class="token keyword">const</span> callback <span class="token operator">=</span> update<span class="token punctuation">.</span>callback<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>callback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          workInProgress<span class="token punctuation">.</span>flags <span class="token operator">|=</span> Callback<span class="token punctuation">;</span>
          <span class="token keyword">const</span> effects <span class="token operator">=</span> queue<span class="token punctuation">.</span>effects<span class="token punctuation">;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>effects <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            queue<span class="token punctuation">.</span>effects <span class="token operator">=</span> <span class="token punctuation">[</span>update<span class="token punctuation">]</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            effects<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>update<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 下一个要更新的update</span>
      update <span class="token operator">=</span> update<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
      <span class="token comment">// 已更新完成</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>update <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pendingQueue <span class="token operator">=</span> queue<span class="token punctuation">.</span>shared<span class="token punctuation">.</span>pending<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pendingQueue <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token comment">// 为了处理在update过程中有触发了update。非推荐做法</span>
          <span class="token comment">// An update was scheduled from inside a reducer. Add the new</span>
          <span class="token comment">// pending updates to the end of the list and keep processing.</span>
          <span class="token keyword">const</span> lastPendingUpdate <span class="token operator">=</span> pendingQueue<span class="token punctuation">;</span>
          <span class="token comment">// Intentionally unsound. Pending updates form a circular list, but we</span>
          <span class="token comment">// unravel them when transferring them to the base queue.</span>
          <span class="token keyword">const</span> firstPendingUpdate <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>lastPendingUpdate<span class="token punctuation">.</span>next<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          lastPendingUpdate<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
          update <span class="token operator">=</span> firstPendingUpdate<span class="token punctuation">;</span>
          queue<span class="token punctuation">.</span>lastBaseUpdate <span class="token operator">=</span> lastPendingUpdate<span class="token punctuation">;</span>
          queue<span class="token punctuation">.</span>shared<span class="token punctuation">.</span>pending <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 表示没有跳过的低优先级更新</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newLastBaseUpdate <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newBaseState <span class="token operator">=</span> newState<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 保存baseState</span>
    queue<span class="token punctuation">.</span>baseState <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newBaseState<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> State<span class="token punctuation">)</span><span class="token punctuation">;</span>
    queue<span class="token punctuation">.</span>firstBaseUpdate <span class="token operator">=</span> newFirstBaseUpdate<span class="token punctuation">;</span>
    queue<span class="token punctuation">.</span>lastBaseUpdate <span class="token operator">=</span> newLastBaseUpdate<span class="token punctuation">;</span>

    <span class="token comment">// Set the remaining expiration time to be whatever is remaining in the queue.</span>
    <span class="token comment">// This should be fine because the only two other things that contribute to</span>
    <span class="token comment">// expiration time are props and context. We're already in the middle of the</span>
    <span class="token comment">// begin phase by the time we start processing the queue, so we've already</span>
    <span class="token comment">// dealt with the props. Context in components that specify</span>
    <span class="token comment">// shouldComponentUpdate is tricky; but we'll have to account for</span>
    <span class="token comment">// that regardless.</span>
    <span class="token function">markSkippedUpdateLanes</span><span class="token punctuation">(</span>newLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    workInProgress<span class="token punctuation">.</span>lanes <span class="token operator">=</span> newLanes<span class="token punctuation">;</span>
    workInProgress<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> newState<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    currentlyProcessingQueue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>看完上面代码，不知道同学是否会产生两个疑问：</p> <ol><li>React在render阶段是可以被中断的，中断后，React需要从root阶段重新构建workInProgess树，那么当前的update是否会丢失呢？</li> <li>React中是如何保证状态的依赖性呢？</li></ol> <blockquote><p>如果要搞清楚这个问题，就要涉及到React中的优先级了，还要涉及React中调度优先级和Lanes优先级的相互转换问题，本章中，我们先认为这个两个优先级是等价的（后面将React中调度的时候回详细讲）。</p></blockquote> <h2 id="正确性"><a href="#正确性" class="header-anchor">#</a> 正确性</h2> <p>在React中，高优先级的任务可以中断低优先级的任务，中断任务后，React会从Root从新构建workInProgress，当前构建的workInprogress会被舍弃掉，那么React是怎么保存本次的Update呢？其实很简单，我们都知道，React中总会维护两棵树，current Tree和workInprogress Tree，current Tree在commit之前，会一直保存，所以把需要更新的Update保存在current Tree中即可。</p> <p>代码如下：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// This is always non-null on a ClassComponent or HostRoot</span>
  <span class="token keyword">const</span> currentQueue<span class="token operator">:</span> UpdateQueue<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>updateQueue<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> currentLastBaseUpdate <span class="token operator">=</span> currentQueue<span class="token punctuation">.</span>lastBaseUpdate<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentLastBaseUpdate <span class="token operator">!==</span> lastBaseUpdate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentLastBaseUpdate <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      currentQueue<span class="token punctuation">.</span>firstBaseUpdate <span class="token operator">=</span> firstPendingUpdate<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      currentLastBaseUpdate<span class="token punctuation">.</span>next <span class="token operator">=</span> firstPendingUpdate<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    currentQueue<span class="token punctuation">.</span>lastBaseUpdate <span class="token operator">=</span> lastPendingUpdate<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>在commit中，workInProgress Tree会被替换到current Tree，也就保证更新完成后，update的正确性</p></blockquote> <h2 id="update状态的连续性"><a href="#update状态的连续性" class="header-anchor">#</a> update状态的连续性</h2> <p>我们都知道update是有优先级（也就是lane字段），如果某个update的优先级低于本次更新的优先级，会被跳过去，那么下次跟新保证数据的连续性。在代码中注释给了完整的解释。</p> <p>我们来看看代码注释中给的解释：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token comment">// For example:</span>
<span class="token comment">//</span>
<span class="token comment">//   Given a base state of '', and the following queue of updates</span>
<span class="token comment">//</span>
<span class="token comment">//     A1 - B2 - C1 - D2</span>
<span class="token comment">//</span>
<span class="token comment">//   where the number indicates the priority, and the update is applied to the</span>
<span class="token comment">//   previous state by appending a letter, React will process these updates as</span>
<span class="token comment">//   two separate renders, one per distinct priority level:</span>
<span class="token comment">//</span>
<span class="token comment">//   First render, at priority 1:</span>
<span class="token comment">//     Base state: ''</span>
<span class="token comment">//     Updates: [A1, C1]</span>
<span class="token comment">//     Result state: 'AC'</span>
<span class="token comment">//</span>
<span class="token comment">//   Second render, at priority 2:</span>
<span class="token comment">//     Base state: 'A'            &lt;-  The base state does not include C1,</span>
<span class="token comment">//                                    because B2 was skipped.</span>
<span class="token comment">//     Updates: [B2, C1, D2]      &lt;-  C1 was rebased on top of B2</span>
<span class="token comment">//     Result state: 'ABCD'</span>
<span class="token comment">//</span>
<span class="token comment">// Because we process updates in insertion order, and rebase high priority</span>
<span class="token comment">// updates when preceding updates are skipped, the final result is deterministic</span>
<span class="token comment">// regardless of priority. Intermediate state may vary according to system</span>
<span class="token comment">// resources, but the final state is always the same.</span>
</code></pre></div><p>下面我来翻译下这段注释：</p> <p>好比我们有四个Update，A1，B2，C1，D2，期中数字代表优先级，数字越低优先级越高，A，B，C，D代表更新的内容。</p> <ul><li><p>第一次更新，优先级为1</p> <p>base state: ''</p> <p>update：[A1, C1]</p> <p>fiber.memoizedState：AC</p> <p>此次更新中，会跳过B2更新，只会根据base state 和A1，C1，计算出最终的结果AC，同时此时的base state 为 'A'</p></li> <li><p>第二次更新，优先级为2</p> <p>base state: 'A'</p> <p>update：[B2, C1,D2]</p> <p>fiber.memoizedState：ABCD</p> <p>此次更新，base state为'A'，在根据base state 和B2，C1，D2，计算出最终的结果ABCD，同时此时的base state 为 ''</p></li></ul> <p>上面的栗子我们可以看出，React不保证中间状态的正确行，只保证最终结果的正确。</p> <blockquote><p>其实这个也很好理解，这个很像Git的<code>rebase</code>。很多逻辑是相同</p></blockquote> <p><strong>下一章我们将介绍React.render()和this.setState的完整过程。</strong></p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">7/23/2021, 1:01:10 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/react-docs/diff/diff.html" class="prev">
        概览
      </a></span> <span class="next"><a href="/react-docs/state/render.html">
        渲染及更新
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/react-docs/assets/js/app.ba34e162.js" defer></script><script src="/react-docs/assets/js/2.ba3186f0.js" defer></script><script src="/react-docs/assets/js/16.544c3c3d.js" defer></script>
  </body>
</html>
